<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Pixel Company â€“ Multiplayer VR</title>

  <!-- A-Frame + Networked-Aframe + Physics -->
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://unpkg.com/networked-aframe/dist/networked-aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/n5ro/aframe-physics-system@v4.0.1/dist/aframe-physics-system.min.js"></script>

  <!-- ================= PLAYER COLOR ================= -->
  <script>
  AFRAME.registerComponent("player-color", {
    schema: { color: { default: "#44ff44" } },
    init() {
      this.applyColor = this.applyColor.bind(this);
      this.el.addEventListener("instantiated", this.applyColor);
    },
    applyColor() {
      const color = this.data.color;
      this.el.querySelectorAll("[geometry]").forEach(el => {
        el.setAttribute("material", "color", color);
      });
    }
  });
  </script>

  <!-- ================= NAME TAG ================= -->
  <script>
  AFRAME.registerComponent("name-tag", {
    init() {
      const name = localStorage.getItem("playerName") || "Player";
      this.label = document.createElement("a-entity");
      this.label.setAttribute("text", {
        value: name,
        align: "center",
        color: "#ffffff",
        width: 2
      });
      this.label.setAttribute("position", "0 0.35 0");
      this.label.setAttribute("billboard", "");
      this.el.appendChild(this.label);
    }
  });
  </script>

  <!-- ================= COMPUTER INPUT ================= -->
  <script>
  AFRAME.registerComponent("computer-input", {
    init() {
      this.step = 0;
      this.buffer = "";
      this.active = false;
      this.screen = this.el.querySelector("[text]");

      window.addEventListener("keydown", e => {
        if (!this.active) return;

        if (e.key === "Enter") {
          if (this.step === 0) {
            localStorage.setItem("playerName", this.buffer || "Player");
            this.buffer = "";
            this.step = 1;
            this.screen.setAttribute("text", "value", "Enter Room Code:");
          } else {
            localStorage.setItem("roomCode", this.buffer || "room1");
            location.reload();
          }
          return;
        }

        if (e.key === "Backspace") {
          this.buffer = this.buffer.slice(0, -1);
        } else if (e.key.length === 1) {
          this.buffer += e.key;
        }

        this.screen.setAttribute(
          "text",
          "value",
          (this.step === 0 ? "Name: " : "Room: ") + this.buffer
        );
      });

      this.el.addEventListener("click", () => {
        this.active = true;
        this.step = 0;
        this.buffer = "";
        this.screen.setAttribute("text", "value", "Enter Name:");
      });
    }
  });
  </script>

  <!-- ================= GRABBABLE ================= -->
  <script>
  AFRAME.registerComponent("grabbable", {
    init() {
      this.grabbing = false;
      this.grabber = null;
      const el = this.el;

      const grabStart = (evt) => {
        this.grabbing = true;
        this.grabber = evt.detail.hand;
        if (!this.grabber) return;

        el.body.sleep();
        el.object3D.position.copy(this.grabber.object3D.position);

        if (el.hasAttribute("color-changer")) {
          const newColor = el.getAttribute("color");
          ["#head", "#leftHand", "#rightHand"].forEach(id => {
            const part = document.querySelector(id);
            if (part) part.setAttribute("player-color", "color:" + newColor);
          });
        }
      };

      const grabEnd = () => {
        this.grabbing = false;
        this.grabber = null;
        if (el.body) el.body.wakeUp();
      };

      el.addEventListener("grab-start", grabStart);
      el.addEventListener("grab-end", grabEnd);
    },

    tick() {
      if (this.grabbing && this.grabber) {
        this.el.object3D.position.copy(this.grabber.object3D.position);
      }
    }
  });
  </script>

  <!-- ================= HAND GRABBER ================= -->
  <script>
  AFRAME.registerComponent("hand-grabber", {
    init() {
      this.target = null;

      this.el.addEventListener("triggerdown", () => {
        if (this.target) {
          this.target.emit("grab-start", { hand: this.el });
        }
      });

      this.el.addEventListener("triggerup", () => {
        if (this.target) {
          this.target.emit("grab-end", { hand: this.el });
        }
        this.target = null;
      });

      this.el.addEventListener("collide", (e) => {
        const other = e.detail.body.el;
        if (other && other.hasAttribute("grabbable")) {
          this.target = other;
        }
      });
    }
  });
  </script>

  <!-- ================= SNAP TURN ================= -->
  <script>
  AFRAME.registerComponent('snap-turn', {
    schema: { angle:{default:45}, deadzone:{default:0.7}, cooldown:{default:250} },
    init(){ this.canSnap = true; },
    tick(){
      const session = this.el.sceneEl.renderer.xr.getSession();
      if(!session || !this.canSnap) return;

      for(const source of session.inputSources){
        if(source.handedness!=='right' || !source.gamepad) continue;
        const x = source.gamepad.axes[2] || source.gamepad.axes[0];

        if(Math.abs(x) > this.data.deadzone){
          const dir = x > 0 ? -1 : 1;
          this.el.object3D.rotation.y += (this.data.angle * dir) * (Math.PI/180);
          this.canSnap = false;
          setTimeout(()=>this.canSnap=true, this.data.cooldown);
          break;
        }
      }
    }
  });
  </script>

  <!-- ================= HAND FOLLOW ================= -->
  <script>
  AFRAME.registerComponent('hand-follow',{
    schema:{target:{type:'selector'}},
    tick(){
      if(!this.data.target) return;
      this.el.object3D.position.copy(this.data.target.object3D.position);
      this.el.object3D.quaternion.copy(this.data.target.object3D.quaternion);
    }
  });
  </script>

  <!-- ================= GORILLA PHYSICS ================= -->
  <script>
  AFRAME.registerComponent('gorilla-physics',{
    schema:{strength:{default:2.0}, gravity:{default:-20}},
    init(){
      this.vel=new THREE.Vector3();
      this.prevL=new THREE.Vector3();
      this.prevR=new THREE.Vector3();
      this.worldPos=new THREE.Vector3();
      this.ray=new THREE.Raycaster();
    },
    tick(_,dtMs){
      if(!dtMs) return;
      const dt=Math.min(dtMs/1000,0.033);
      const rig=this.el.object3D;
      const surfaces=[...this.el.sceneEl.querySelectorAll('.climbable')].map(e=>e.object3D);

      const processHand=(id,prevPos)=>{
        const hand=document.querySelector(id);
        if(!hand) return;

        const currPos=hand.object3D.position;
        const handVelLocal=currPos.clone().sub(prevPos).divideScalar(dt);

        hand.object3D.getWorldPosition(this.worldPos);
        this.ray.set(this.worldPos,new THREE.Vector3(0,-1,0));
        const hits=this.ray.intersectObjects(surfaces,true);

        if(hits.length && hits[0].distance<0.18 && handVelLocal.y<-0.2){
          const worldVel=handVelLocal.clone().applyQuaternion(rig.quaternion);
          this.vel.x=-worldVel.x*this.data.strength;
          this.vel.z=-worldVel.z*this.data.strength;
          this.vel.y=-worldVel.y*(this.data.strength*1.5);
        }
        prevPos.copy(currPos);
      };

      processHand('#leftHand',this.prevL);
      processHand('#rightHand',this.prevR);

      this.vel.y+=this.data.gravity*dt;
      rig.position.addScaledVector(this.vel,dt);

      if(rig.position.y<=0){
        rig.position.y=0;
        if(this.vel.y<0) this.vel.y=0;
        this.vel.x*=0.75;
        this.vel.z*=0.75;
      }
    }
  });
  </script>

  <!-- ================= VOICE CHAT ================= -->
  <script>
  AFRAME.registerComponent("voice-chat", {
    init() {
      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(stream => {
          if (NAF.connection?.adapter?.setLocalMediaStream) {
            NAF.connection.adapter.setLocalMediaStream(stream);
          }
        });
    }
  });
  </script>

</head>

<body>

<!-- ================= DYNAMIC ROOM CODE ================= -->
<script>
const room = localStorage.getItem("roomCode") || "room1";
document.write(`
<a-scene background="color:#111"
physics="debug:false"
networked-scene="app:gorilla; room:${room}; adapter:webrtc">
`);
</script>

<!-- ================= ASSETS + TEMPLATES ================= -->
<a-assets>

  <!-- Remote avatar template -->
  <a-template id="avatar-template">
    <a-entity>
      <a-sphere class="remote-head" radius="0.25" position="0 1.6 0" color="#39f"></a-sphere>
      <a-box class="remote-left-hand" width="0.1" height="0.1" depth="0.1"
             position="-0.3 1.2 -0.3" color="#39f"></a-box>
      <a-box class="remote-right-hand" width="0.1" height="0.1" depth="0.1"
             position="0.3 1.2 -0.3" color="#39f"></a-box>
    </a-entity>
  </a-template>

  <!-- Local head template -->
  <a-template id="head-template">
    <a-sphere radius="0.2"></a-sphere>
  </a-template>

  <!-- Local left hand template -->
  <a-template id="left-hand-template">
    <a-box width="0.1" height="0.1" depth="0.1"></a-box>
  </a-template>

  <!-- Local right hand template -->
  <a-template id="right-hand-template">
    <a-box width="0.1" height="0.1" depth="0.1"></a-box>
  </a-template>

</a-assets>

<!-- ================= PLAYER ================= -->
<a-entity id="player"
          networked="template:#avatar-template; attachTemplateToLocal:false">

  <a-entity id="rig" snap-turn gorilla-physics>

    <!-- NETWORKED HEAD -->
    <a-entity id="head"
              position="0 1.6 0"
              name-tag
              networked="template:#head-template; attachTemplateToLocal:false">
    </a-entity>

    <!-- CAMERA -->
    <a-camera position="0 1.6 0"></a-camera>

    <!-- CONTROLLERS -->
    <a-entity id="lc" oculus-touch-controls="hand:left"></a-entity>
    <a-entity id="rc" oculus-touch-controls="hand:right"></a-entity>

    <!-- NETWORKED HANDS -->
    <a-entity id="leftHand"
              hand-follow="target:#lc"
              hand-grabber
              static-body
              networked="template:#left-hand-template; attachTemplateToLocal:false">
    </a-entity>

    <a-entity id="rightHand"
              hand-follow="target:#rc"
              hand-grabber
              static-body
              networked="template:#right-hand-template; attachTemplateToLocal:false">
    </a-entity>

  </a-entity>
</a-entity>

<!-- ================= WORLD ================= -->
<a-plane class="climbable"
         rotation="-90 0 0"
         width="100"
         height="100"
         material="color:#00ff00; shader:flat"
         static-body></a-plane>

<!-- COLOR PANEL -->
<a-box position="1 1 -1" width="2" height="0.2" depth="2" color="#555"></a-box>

<!-- COLOR CUBES -->
<a-box position="0.5 1.2 -1" width="0.4" height="0.4" depth="0.4"
       color="#ff0000" grabbable color-changer dynamic-body></a-box>

<a-box position="1 1.2 -1" width="0.4" height="0.4" depth="0.4"
       color="#00ff00" grabbable color-changer dynamic-body></a-box>

<a-box position="1.5 1.2 -1" width="0.4" height="0.4" depth="0.4"
       color="#0000ff" grabbable color-changer dynamic-body></a-box>

<!-- COMPUTER -->
<a-box position="0 1 -2" width="1" height="0.6" depth="0.2" color="#222">
  <a-plane position="0 0 0.11" width="0.9" height="0.45" color="#000"
    text="value: Click then type; align:center; color:#0f0; width:1.8"></a-plane>
  <a-entity computer-input></a-entity>
</a-box>

</a-scene>

</body>
</html>
