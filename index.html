<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Pixel Company - Stable Build</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>

  <script>
    AFRAME.registerComponent('snap-turn', {
      schema: { leftController: { type: 'selector' }, rightController: { type: 'selector' } },
      init: function () {
        this.enabled = true; 
        this.canTurn = true;
        this.data.leftController.addEventListener('ybuttondown', () => { this.enabled = !this.enabled; });
        this.el.addEventListener('axismove', (e) => {
          if (!this.enabled || e.srcElement !== this.data.rightController) return;
          const x = e.detail.axis[2] || e.detail.axis[0];
          if (Math.abs(x) < 0.7) { this.canTurn = true; return; }
          if (this.canTurn) {
            const rot = this.el.getAttribute('rotation');
            rot.y -= Math.sign(x) * 45;
            this.el.setAttribute('rotation', rot);
            this.canTurn = false;
          }
        });
      }
    });

    AFRAME.registerComponent('gorilla-physics', {
      schema: { rig: { type: 'selector' }, strength: { default: 2.1 }, gravity: { default: -20 } },
      init: function () {
        this.vel = new THREE.Vector3(0, 0, 0);
        this.prev = new THREE.Vector3();
        this.curr = new THREE.Vector3();
        this.handVel = new THREE.Vector3();
        this.cooldown = 0;
        this.raycaster = new THREE.Raycaster();
        this.downVec = new THREE.Vector3(0, -1, 0);
        this.isGrounded = false;

        this.el.sceneEl.addEventListener('loaded', () => {
          this.surfaces = [...this.el.sceneEl.querySelectorAll('.climbable')].map(e => e.object3D);
        });
      },
      tick: function (t, dtMs) {
        if (!dtMs || !this.data.rig || !this.surfaces) return;
        const dt = dtMs / 1000;
        const rig = this.data.rig.object3D;

        if (this.cooldown > 0) this.cooldown -= dt;
        this.el.object3D.getWorldPosition(this.curr);
        this.handVel.copy(this.curr).sub(this.prev).divideScalar(dt);
        this.prev.copy(this.curr);

        // --- GROUND DETECTION ---
        // Raycast from 1.5m up to find the floor accurately
        const rayOrigin = new THREE.Vector3(rig.position.x, rig.position.y + 1.5, rig.position.z);
        this.raycaster.set(rayOrigin, this.downVec);
        const hits = this.raycaster.intersectObjects(this.surfaces, true);
        
        let floorY = -999;
        if (hits.length > 0) floorY = hits[0].point.y;

        // --- THE "STAY PUT" LOGIC ---
        // If we are at or below the floor, we are GROUNDED
        if (rig.position.y <= floorY + 0.05 && this.vel.y <= 0) {
            this.isGrounded = true;
            rig.position.y = floorY; // Gently set position
            this.vel.y = 0;          // Kill velocity to prevent launching
        } else {
            this.isGrounded = false;
        }

        // --- HAND PUSH ---
        this.raycaster.set(this.curr, this.downVec);
        const pushHits = this.raycaster.intersectObjects(this.surfaces, true);
        if (pushHits.length && pushHits[0].distance < 0.2) {
          if (this.handVel.y < -0.4 && this.cooldown <= 0) {
            // Apply new velocity
            this.vel.x = -this.handVel.x * this.data.strength;
            this.vel.z = -this.handVel.z * this.data.strength;
            this.vel.y = -this.handVel.y * (this.data.strength * 1.3);
            
            // VELOCITY CAP: Prevent being "sent flying"
            this.vel.y = Math.min(this.vel.y, 15); 
            
            this.cooldown = 0.2;
            this.isGrounded = false;
          }
        }

        // --- APPLY PHYSICS ---
        if (!this.isGrounded) {
            this.vel.y += this.data.gravity * dt;
            rig.position.addScaledVector(this.vel, dt);
        }

        // Friction and air resistance
        const friction = this.isGrounded ? 0.8 : 0.98;
        this.vel.x *= friction;
        this.vel.z *= friction;
      }
    });

    AFRAME.registerComponent('hand-follow', {
      schema: { target: { type: 'selector' } },
      tick: function () {
        if (!this.data.target) return;
        this.el.object3D.position.copy(this.data.target.object3D.position);
        this.el.object3D.quaternion.copy(this.data.target.object3D.quaternion);
      }
    });
  </script>
</head>

<body>
  <a-scene background="color: #87CEEB">
    <a-entity light="type: hemisphere; intensity: 1.2"></a-entity>
    
    <a-entity id="rig" position="0 0.1 0" snap-turn="leftController:#lc; rightController:#rc">
      <a-camera position="0 0 0" look-controls camera="near: 0.1">
          <a-entity position="0 -0.6 0.4">
            <a-sphere position="0 0.5 -0.1" radius="0.15" color="white"></a-sphere>
            <a-box position="0 0.48 -0.22" width="0.16" height="0.12" depth="0.05" color="#ccc"></a-box>
            <a-sphere position="0 0.1 -0.1" radius="0.3" color="white" scale="1 1.1 0.8">
                <a-box position="0 0 -0.25" width="0.22" height="0.35" depth="0.05" color="#bbb"></a-box>
            </a-sphere>
          </a-entity>
      </a-camera>
      
      <a-entity id="lc" tracked-controls="hand: left"></a-entity>
      <a-entity id="rc" tracked-controls="hand: right"></a-entity>

      <a-box width="0.1" height="0.05" depth="0.15" color="white"
             hand-follow="target:#lc" gorilla-physics="rig:#rig"></a-box>
      <a-box width="0.1" height="0.05" depth="0.15" color="white"
             hand-follow="target:#rc" gorilla-physics="rig:#rig"></a-box>
    </a-entity>

    <a-plane class="climbable" rotation="-90 0 0" width="100" height="100" color="#3A5F0B"></a-plane>
    <a-box class="climbable" position="0 0.5 -5" width="4" height="1" depth="4" color="#777"></a-box>
  </a-scene>
</body>
</html>
