<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Pixel Company</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>

  <script>
    /* =========================================================
       SNAP TURN (WITH TOGGLE LOGIC)
    ========================================================= */
    AFRAME.registerComponent('snap-turn', {
      schema: { 
        rig: { type: 'selector' }, 
        leftController: { type: 'selector' },
        sensitivity: { default: 0.5 } 
      },
      init: function () {
        this.canTurn = true;
        this.enabled = true; // Snap turn starts ON

        // Listen for Y Button on the Left Controller to toggle
        if (this.data.leftController) {
          this.data.leftController.addEventListener('ybuttondown', () => {
            this.enabled = !this.enabled;
            console.log("Snap Turn Enabled:", this.enabled);
            // Optional: Add a haptic pulse to confirm the toggle
            this.el.components['tracked-controls']?.controller?.hapticActuators?.[0]?.pulse(0.2, 20);
          });
        }

        this.el.addEventListener('axismove', (e) => {
          if (!this.enabled) return; // Do nothing if toggled off

          const x = e.detail.axis[2] || e.detail.axis[0];
          if (Math.abs(x) < this.data.sensitivity) {
            this.canTurn = true;
            return;
          }
          if (this.canTurn) {
            const rotation = this.data.rig.getAttribute('rotation');
            rotation.y -= Math.sign(x) * 45;
            this.data.rig.setAttribute('rotation', rotation);
            this.canTurn = false;
          }
        });
      }
    });

    /* =========================================================
       GORILLA PHYSICS
    ========================================================= */
    AFRAME.registerComponent('gorilla-physics', {
      schema: { rig: { type: 'selector' }, strength: { default: 2.0 }, gravity: { default: -16 } },
      init: function () {
        this.vel = new THREE.Vector3();
        this.prev = new THREE.Vector3();
        this.curr = new THREE.Vector3();
        this.handVel = new THREE.Vector3();
        this.cooldown = 0;
        this.raycaster = new THREE.Raycaster();
        this.down = new THREE.Vector3(0, -1, 0);
        this.surfaces = [];

        this.el.sceneEl.addEventListener('loaded', () => {
          this.surfaces = [...this.el.sceneEl.querySelectorAll('.climbable')].map(e => e.object3D);
        });
      },
      tick: function (t, dtMs) {
        if (!dtMs || !this.data.rig) return;
        const dt = dtMs / 1000;
        const rig = this.data.rig.object3D;

        if (this.cooldown > 0) this.cooldown -= dt;
        this.el.object3D.getWorldPosition(this.curr);
        this.handVel.copy(this.curr).sub(this.prev).divideScalar(dt);
        this.prev.copy(this.curr);

        this.raycaster.set(this.curr, this.down);
        const hits = this.raycaster.intersectObjects(this.surfaces, true);

        if (hits.length && hits[0].distance < 0.15 && this.handVel.y < -0.4 && this.cooldown <= 0) {
          this.vel.x = -this.handVel.x * this.data.strength;
          this.vel.z = -this.handVel.z * this.data.strength;
          this.vel.y = -this.handVel.y * (this.data.strength * 1.2);
          this.vel.clampScalar(-9, 9);
          this.cooldown = 0.15;
          this.el.components['tracked-controls']?.controller?.hapticActuators?.[0]?.pulse(0.5, 40);
        }

        this.vel.y += this.data.gravity * dt;
        rig.position.addScaledVector(this.vel, dt);

        if (rig.position.y < 0) {
          rig.position.y = 0;
          this.vel.y = 0;
          this.vel.x *= 0.8; 
          this.vel.z *= 0.8;
        }
        this.vel.x *= 0.95;
        this.vel.z *= 0.95;
      }
    });

    /* =========================================================
       HAND FOLLOW
    ========================================================= */
    AFRAME.registerComponent('hand-follow', {
      schema: { target: { type: 'selector' }, rig: { type: 'selector' }, maxLength: { default: 0.85 } },
      tick: function () {
        if (!this.data.target || !this.data.rig) return;
        const hand = this.el.object3D;
        const target = this.data.target.object3D;
        const rigPos = this.data.rig.object3D.position;

        let desired = new THREE.Vector3().copy(target.position);
        let offset = desired.clone().sub(rigPos);
        if (offset.length() > this.data.maxLength) {
          offset.setLength(this.data.maxLength);
          desired.copy(rigPos).add(offset);
        }
        hand.position.lerp(desired, 0.4);
        hand.quaternion.slerp(target.quaternion, 0.4);
      }
    });
  </script>
</head>

<body>
  <a-scene background="color: #87CEEB">
    
    <a-entity id="rig" position="0 0 0">
      <a-camera position="0 0 0" look-controls></a-camera>

      <a-entity id="lc" tracked-controls="hand: left"></a-entity>
      
      <a-entity id="rc" tracked-controls="hand: right" snap-turn="rig: #rig; leftController: #lc"></a-entity>

      <a-sphere radius="0.06" color="#222" hand-follow="target:#lc; rig:#rig" gorilla-physics="rig:#rig"></a-sphere>
      <a-sphere radius="0.06" color="#222" hand-follow="target:#rc; rig:#rig" gorilla-physics="rig:#rig"></a-sphere>
    </a-entity>

    <a-plane class="climbable" rotation="-90 0 0" width="50" height="50" color="#3A5F0B"></a-plane>
    <a-box class="climbable" position="0 0.5 -5" color="#777"></a-box>

  </a-scene>
</body>
</html>
