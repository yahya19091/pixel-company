<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Pixel Company â€“ Gorilla Prototype Final</title>
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://unpkg.com/networked-aframe/dist/networked-aframe.min.js"></script>

    <script>
        /* =========================================================
           GORILLA PHYSICS (Stable + True Gravity)
        ========================================================= */
        AFRAME.registerComponent('gorilla-physics', {
            schema: {
                strength: { default: 2.1 },
                gravity: { default: -25 },
                maxSpeed: { default: 15 }
            },
            init() {
                this.vel = new THREE.Vector3();
                this.handPrevL = new THREE.Vector3();
                this.handPrevR = new THREE.Vector3();
                this.handCurr = new THREE.Vector3();
                this.tempVec = new THREE.Vector3();
                this.ready = false;
            },
            tick(_, dtMs) {
                if (!dtMs) return;

                // 1. LAG PROTECTION: Cap delta time so spikes don't launch you
                const dt = Math.min(dtMs / 1000, 0.033); 
                const rig = this.el.object3D;

                const handL = document.querySelector('#lc')?.object3D;
                const handR = document.querySelector('#rc')?.object3D;
                if (!handL || !handR) return;

                const processHand = (hand, prevPos) => {
                    hand.getWorldPosition(this.handCurr);
                    if (this.ready) {
                        this.tempVec.copy(this.handCurr).sub(prevPos).divideScalar(dt);

                        // Only push if hand is near ground and movement isn't a tracking glitch
                        if (this.tempVec.length() < 30) { 
                            // Check Y relative to world (0.15m from floor)
                            if (this.handCurr.y < 0.15 && this.tempVec.y < -0.1) {
                                this.vel.x = -this.tempVec.x * this.data.strength;
                                this.vel.z = -this.tempVec.z * this.data.speed; // corrected mapping
                                this.vel.y = -this.tempVec.y * (this.data.strength * 1.5);
                            }
                        }
                    }
                    prevPos.copy(this.handCurr);
                };

                processHand(handL, this.handPrevL);
                processHand(handR, this.handPrevR);
                this.ready = true;

                // 2. APPLY GRAVITY & VELOCITY
                this.vel.y += this.data.gravity * dt;
                this.vel.clampLength(0, this.data.maxSpeed); // Yeet protection
                rig.position.addScaledVector(this.vel, dt);

                // 3. TRUE FLOOR COLLISION (Y=0)
                if (rig.position.y <= 0) {
                    rig.position.y = 0;
                    if (this.vel.y < 0) this.vel.y = 0;
                    this.vel.x *= 0.85; // Ground friction
                    this.vel.z *= 0.85;
                }
            }
        });

        /* =========================================================
           SNAP TURN (Right Stick)
        ========================================================= */
        AFRAME.registerComponent('snap-turn', {
            init() { this.cooldown = false; },
            tick() {
                const gp = navigator.getGamepads()[1]; // Right controller
                if (!gp || this.cooldown) return;
                const xAxis = gp.axes[2] || gp.axes[0];
                if (Math.abs(xAxis) > 0.8) {
                    this.el.object3D.rotation.y -= Math.sign(xAxis) * THREE.MathUtils.degToRad(30);
                    this.cooldown = true;
                    setTimeout(() => this.cooldown = false, 250);
                }
            }
        });
    </script>
</head>

<body>
    <a-scene networked-scene="room: pixel-company; debug: false" background="color: #87CEEB">
        
        <a-entity light="type: hemisphere; intensity: 1.2"></a-entity>
        <a-entity light="type: directional; intensity: 0.5" position="1 2 1"></a-entity>

        <a-entity id="rig" position="0 3 0" gorilla-physics snap-turn>
            
            <a-camera look-controls camera="near: 0.05"></a-camera>

            <a-entity id="body">
                <a-sphere radius="0.4" color="white" position="0 0.4 0"></a-sphere>
                <a-box width="0.5" height="0.6" depth="0.3" color="white" position="0 0.3 0"></a-box>
            </a-entity>

            <a-entity id="lc" tracked-controls="hand:left"></a-entity>
            <a-entity id="rc" tracked-controls="hand:right"></a-entity>

            <a-entity id="leftHandVisual" position="0 0 0">
                <a-box width="0.1" height="0.05" depth="0.1" color="#eee"></a-box>
            </a-entity>
            <a-entity id="rightHandVisual" position="0 0 0">
                <a-box width="0.1" height="0.05" depth="0.1" color="#eee"></a-box>
            </a-entity>
        </a-entity>

        <a-plane rotation="-90 0 0" width="100" height="100" color="#3A5F0B" class="climbable"></a-plane>
        
    </a-scene>

    <script>
        // Simple helper to keep hand visuals on tracked controls
        const updateHands = () => {
            const lc = document.querySelector('#lc').object3D;
            const rc = document.querySelector('#rc').object3D;
            document.querySelector('#leftHandVisual').object3D.position.copy(lc.position);
            document.querySelector('#rightHandVisual').object3D.position.copy(rc.position);
            requestAnimationFrame(updateHands);
        };
        updateHands();
    </script>
</body>
</html>
